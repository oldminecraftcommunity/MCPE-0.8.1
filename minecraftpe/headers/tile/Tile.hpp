#pragma once
#include <_types.h>
#include <math/AABB.hpp>
#include <string>
#include <rendering/TextureUVCoordinateSet.hpp>
#include <vector>
#include <memory>
#include <rendering/TextureAtlas.hpp>

struct Level;
struct AABB;
struct Vec3;
struct Entity;
struct LevelSource;
struct Player;
struct Random;
struct Mob;
struct Material;

struct Tile{
	struct SoundType{
		float field_0, field_4;
		std::string field_8, field_C;
		SoundType(const std::string&, const std::string&, float, float); //TODO does not exist
		SoundType(const std::string&, float, float);
		//not needed? ~SoundType();
	};

	static Tile* rock;
	static Tile* grass;
	static Tile* dirt;
	static Tile* stoneBrick;
	static Tile* wood;
	static Tile* sapling;
	static Tile* unbreakable;
	static Tile* water;
	static Tile* calmWater;
	static Tile* lava;
	static Tile* calmLava;
	static Tile* sand;
	static Tile* gravel;
	static Tile* goldOre;
	static Tile* ironOre;
	static Tile* coalOre;
	static Tile* treeTrunk;
	static Tile* leaves;
	static Tile* sponge;
	static Tile* glass;
	static Tile* lapisOre;
	static Tile* lapisBlock;
	static Tile* sandStone;
	static Tile* bed;
	static Tile* goldenRail;
	static Tile* web;
	static Tile* tallgrass;
	static Tile* deadBush;
	static Tile* cloth;
	static Tile* flower;
	static Tile* rose;
	static Tile* mushroom1;
	static Tile* mushroom2;
	static Tile* goldBlock;
	static Tile* ironBlock;
	static Tile* stoneSlab;
	static Tile* stoneSlabHalf;
	static Tile* redBrick;
	static Tile* tnt;
	static Tile* bookshelf;
	static Tile* mossStone;
	static Tile* obsidian;
	static Tile* torch;
	static Tile* stairs_wood;
	static Tile* chest;
	static Tile* emeraldOre;
	static Tile* emeraldBlock;
	static Tile* workBench;
	static Tile* crops;
	static Tile* farmland;
	static Tile* furnace;
	static Tile* furnace_lit;
	static Tile* sign;
	static Tile* door_wood;
	static Tile* ladder;
	static Tile* rail;
	static Tile* stairs_stone;
	static Tile* wallSign;
	static Tile* door_iron;
	static Tile* redStoneOre;
	static Tile* redStoneOre_lit;
	static Tile* topSnow;
	static Tile* ice;
	static Tile* snow;
	static Tile* cactus;
	static Tile* clay;
	static Tile* reeds;
	static Tile* fence;
	static Tile* pumpkin;
	static Tile* netherrack;
	static Tile* lightGem;
	static Tile* litPumpkin;
	static Tile* cake;
	static Tile* invisible_bedrock;
	static Tile* trapdoor;
	static Tile* stoneBrickSmooth;
	static Tile* ironFence;
	static Tile* thinGlass;
	static Tile* melon;
	static Tile* pumpkinStem;
	static Tile* melonStem;
	static Tile* fenceGate;
	static Tile* stairs_brick;
	static Tile* woodStairsDark;
	static Tile* woodStairsBirch;
	static Tile* woodStairsJungle;
	static Tile* stairs_stoneBrickSmooth;
	static Tile* netherBrick;
	static Tile* stairs_netherBricks;
	static Tile* activatorRail;
	static Tile* stairs_sandStone;
	static Tile* cobbleWall;
	static Tile* carrots;
	static Tile* potatoes;
	static Tile* quartzBlock;
	static Tile* stairs_quartz;
	static Tile* woodSlab;
	static Tile* woodSlabHalf;
	static Tile* hayBlock;
	static Tile* woolCarpet;
	static Tile* coalBlock;
	static Tile* beetroot;
	static Tile* stonecutterBench;
	static Tile* glowingObsidian;
	static Tile* netherReactor;
	static Tile* info_updateGame1;
	static Tile* info_updateGame2;
	static Tile* info_reserved6;
	static Tile* fire;

	static Tile::SoundType SOUND_NORMAL;
	static Tile::SoundType SOUND_WOOD;
	static Tile::SoundType SOUND_GRAVEL;
	static Tile::SoundType SOUND_GRASS;
	static Tile::SoundType SOUND_STONE;
	static Tile::SoundType SOUND_METAL;
	static Tile::SoundType SOUND_GLASS;
	static Tile::SoundType SOUND_CLOTH;
	static Tile::SoundType SOUND_SAND;
	static std::string WOOD_NAMES[];
	static Tile::SoundType SOUND_SILENT;

	static std::string TILE_DESCRIPTION_PREFIX;

	static bool_t shouldTick[256];
	static bool_t isEntityTile[256];
	static bool_t solid[256];
	static bool_t lightEmission[256];
	static bool_t lightBlock[256];
	static bool_t translucent[256];

	static Tile* tiles[256];
	static std::shared_ptr<TextureAtlas> _terrainTextureAtlas;

	TextureUVCoordinateSet textureUV;
	int32_t blockID;
	float minX, minY, minZ, maxX, maxY, maxZ;
	const Tile::SoundType* soundType;
	float field_3C;
	const Material* material;
	float slipperiness;
	float blockHardness, blockResistance;
	int32_t field_50, field_54;
	bool_t goodGraphics;
	int8_t field_59, field_5A, field_5B;
	int32_t field_5C;
	AABB aabb;
	bool_t replaceable;
	int8_t field_79, field_7A, field_7B;
	std::string descriptionId;


	static void initTiles(std::shared_ptr<TextureAtlas>);
	static void teardownTiles();
	static int32_t transformToValidBlockId(int32_t);
	static int32_t transformToValidBlockId(int32_t, int32_t, int32_t, int32_t);

	Tile(int32_t, const Material*);
	Tile(int32_t, TextureUVCoordinateSet, const Material*);
	Tile(int32_t, std::string, const Material*);

	bool_t containsX(const Vec3&);
	bool_t containsY(const Vec3&);
	bool_t containsZ(const Vec3&);
	int32_t getIDByName(const std::string&, bool_t);
	struct TextureAtlasTextureItem* getTextureItem(const std::string&);
	TextureUVCoordinateSet getTextureUVCoordinateSet(const std::string&, int32_t);
	bool_t isFaceVisible(Level*, int32_t, int32_t, int32_t, int32_t);
	void popResource(Level*, int32_t, int32_t, int32_t, const struct ItemInstance&);
	Tile* setCategory(int32_t, int32_t);

	virtual ~Tile();
	virtual int32_t getTileType();
	virtual bool_t onFertilized(Level*, int32_t, int32_t, int32_t);
	virtual bool_t isCubeShaped();
	virtual int32_t getRenderShape();
	virtual Tile* setShape(float, float, float, float, float, float);
	virtual void updateShape(LevelSource*, int32_t, int32_t, int32_t);
	virtual void updateDefaultShape(void);
	virtual void addLights(Level*, int32_t, int32_t, int32_t);
	virtual float getBrightness(LevelSource*, int32_t, int32_t, int32_t);
	virtual bool_t shouldRenderFace(LevelSource*, int32_t, int32_t, int32_t, int32_t);
	virtual TextureUVCoordinateSet* getTexture(int32_t);
	virtual TextureUVCoordinateSet* getTexture(int32_t, int32_t);
	virtual TextureUVCoordinateSet* getTexture(LevelSource*, int32_t, int32_t, int32_t, int32_t);
	virtual TextureUVCoordinateSet* getCarriedTexture(int32_t, int32_t);
	virtual AABB* getAABB(Level*, int32_t, int32_t, int32_t);
	virtual void addAABBs(Level*, int32_t, int32_t, int32_t, const AABB*, std::vector<AABB>&);
	virtual AABB getTileAABB(Level*, int32_t, int32_t, int32_t);
	virtual bool_t isSolidRender();
	virtual bool_t isPathfindable(LevelSource*, int32_t, int32_t, int32_t);
	virtual bool_t isUnbreakable();
	virtual bool_t isLiquidTile();
	virtual int32_t getTileEntityType(void);
	virtual bool_t mayPick();
	virtual bool_t mayPick(int32_t, bool_t);
	virtual bool_t mayPlace(Level *, int32_t, int32_t, int32_t, uint8_t);
	virtual bool_t mayPlace(Level*, int32_t, int32_t, int32_t);
	virtual int32_t getTickDelay();
	virtual void tick(Level*, int32_t, int32_t, int32_t, Random*);
	virtual void animateTick(Level*, int32_t, int32_t, int32_t, Random*);
	virtual void destroy(Level*, int32_t, int32_t, int32_t, int32_t);
	virtual void playerWillDestroy(Level*, int32_t, int32_t, int32_t, int32_t, Player*);
	virtual void neighborChanged(Level*, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);
	virtual void onPlace(Level*, int32_t, int32_t, int32_t);
	virtual void onRemove(Level*, int32_t, int32_t, int32_t);
	virtual void onGraphicsModeChanged(bool_t);
	virtual int32_t getResource(int32_t, Random*);
	virtual int32_t getResourceCount(Random*);
	virtual float getDestroyProgress(Player*);
	virtual void spawnResources(Level*, int32_t, int32_t, int32_t, int32_t);
	virtual void spawnResources(Level *, int32_t, int32_t, int32_t, int32_t, float);
	virtual bool_t spawnBurnResources(Level*, float, float, float);
	virtual float getExplosionResistance(Entity*);
	virtual HitResult clip(Level*, int32_t, int32_t, int32_t, const Vec3&, const Vec3&);
	virtual void wasExploded(Level*, int32_t, int32_t, int32_t);
	virtual int32_t getRenderLayer();
	virtual bool_t use(Level*, int32_t, int32_t, int32_t, Player*);
	virtual void stepOn(Level*, int32_t, int32_t, int32_t, Entity*);
	virtual void fallOn(Level*, int32_t, int32_t, int32_t, Entity*, float);
	virtual int32_t getPlacementDataValue(Level*, int32_t, int32_t, int32_t, int32_t, float, float, float, struct Mob*, int32_t);
	virtual void prepareRender(Level*, int32_t, int32_t, int32_t);
	virtual void attack(Level*, int32_t, int32_t, int32_t, Player*);
	virtual void handleEntityInside(Level*, int32_t, int32_t, int32_t, Entity*, Vec3&);
	virtual int32_t getColor(int32_t);
	virtual int32_t getColor(LevelSource*, int32_t, int32_t, int32_t);
	virtual float getThickness();
	virtual bool_t isSignalSource();
	virtual int32_t getSignal(LevelSource*, int32_t, int32_t, int32_t);
	virtual int32_t getSignal(LevelSource*, int32_t, int32_t, int32_t, int32_t);
	virtual int32_t getDirectSignal(Level*, int32_t, int32_t, int32_t, int32_t);
	virtual void entityInside(Level*, int32_t, int32_t, int32_t, Entity*);
	virtual void playerDestroy(Level*, Player*, int32_t, int32_t, int32_t, int32_t);
	virtual bool_t canSurvive(Level*, int32_t, int32_t, int32_t);
	virtual std::string getName();
	virtual std::string getDescriptionId(void);
	virtual std::string getDescriptionId(const struct ItemInstance*);
	virtual std::string getTypeDescriptionId(int32_t);
	virtual Tile* setDescriptionId(const std::string&);
	virtual void triggerEvent(Level*, int32_t, int32_t, int32_t, int32_t, int32_t);
	virtual TextureUVCoordinateSet* getTextureNum(int32_t);
	virtual Tile* setSoundType(const Tile::SoundType&);
	virtual Tile* setLightBlock(int32_t);
	virtual Tile* setLightEmission(float);
	virtual Tile* setExplodeable(float);
	virtual Tile* setDestroyTime(float);
	virtual void setTicking(bool_t);
	virtual int32_t getSpawnResourcesAuxValue(int32_t);
	virtual Tile* init();
};
