#pragma once
#include <_types.h>
#include <entity/Entity.hpp>
#include <math/Vec3.hpp>
#include <util/Random.hpp>
#include <entity/ai/GoalSelector.hpp>
struct LookControl;
struct MoveControl;
struct JumpControl;
struct BodyControl;
struct PathNavigation;
struct TextureUVCoordinateSet;
struct Sensing;

struct Mob : Entity{
	int32_t field_118;
	float field_11C, field_120, field_124, field_128;
	float headYaw;
	float field_130, field_134, field_138;
	int32_t health, prevHealthMaybe;
	int32_t hurtTime;
	int32_t field_148;
	float field_14C;
	int32_t deathTime, attackTime;
	float field_158;
	float field_15C;
	int32_t field_160, field_164;
	float field_168, field_16C, field_170;
	Vec3 field_174;
	int32_t field_180, field_184;
	Random random;
	bool_t hasArmorMaybe;
	int8_t field_B59, field_B5A, field_B5B;
	float moveStrafe, moveForward;
	float field_B64;
	bool_t field_B68;
	int8_t field_B69, field_B6A, field_B6B;
	int32_t field_B6C;
	int32_t noActionTime;
	float field_B74;
	float jumpMovementFactor;
	float field_B7C;
	std::string skin;
	std::string field_B84;
	int32_t field_B88;
	float field_B8C, field_B90, field_B94, field_B98;
	float field_B9C, field_BA0;
	int32_t field_BA4, field_BA8;
	float field_BAC, field_BB0, field_BB4, field_BB8, field_BBC;
	int32_t field_BC0, field_BC4;
	float field_BC8, field_BCC, field_BD0, field_BD4;
	float field_BD8, field_BDC, field_BE0, field_BE4;
	int32_t field_BE8;
	int8_t field_BEC;
	bool_t isJumping;
	bool_t field_BEE, field_BEF;
	LookControl* lookControl;
	MoveControl* moveControl;
	JumpControl* jumpControl;
	BodyControl* bodyControl;
	PathNavigation* navigation;
	Sensing* sensing;
	GoalSelector goalSelector;
	GoalSelector goalSelector2;
	int32_t targetEID;
	int32_t maybeEntityWhichIsBeingLookedByThisEntity;
	int32_t field_C58, field_C5C, field_C60, field_C64;
	float speed;

	Mob(Level*);
	void _init();
	void checkDespawn(Mob*);
	void checkDespawn();
	JumpControl* getJumpControl();
	LookControl* getLookControl();
	MoveControl* getMoveControl();
	PathNavigation* getNavigation();
	Sensing* getSensing();
	bool_t getSharedFlag(int32_t);
	float getSpeed();
	float getYHeadRot();
	bool_t interpolateOnly();
	void pushEntities();
	void setJumping(bool_t);
	void setSharedFlag(int32_t, bool_t);
	void setSpeed(float);
	void setYHeadRot(float);
	void setYya(float);
	void updateAttackAnim();
	Mob* updateMobId(int32_t*);

	virtual ~Mob();
	virtual void reset();
	virtual void lerpTo(float, float, float, float, float, int32_t);
	virtual void tick();
	virtual void baseTick();
	virtual void rideTick();
	virtual float getHeadHeight();
	virtual bool_t isPickable();
	virtual bool_t isPushable();
	virtual bool_t isShootable();
	virtual bool_t isSneaking();
	virtual bool_t isAlive();
	virtual bool_t isOnFire();
	virtual bool_t hurt(Entity*, int32_t);
	virtual void animateHurt();
	virtual void handleEntityEvent(int8_t);
	virtual SynchedEntityData* getEntityData() const;
	//there are two getEntityData functions for some reason
	virtual int32_t getEntityTypeId() const = 0;
	virtual bool_t isMob();
	virtual void setSize(float, float);
	virtual void outOfWorld();
	virtual void causeFallDamage(float);
	virtual void readAdditionalSaveData(CompoundTag*);
	virtual void addAdditonalSaveData(CompoundTag*);
	virtual void postInit();
	virtual void knockback(Entity*, int32_t, float, float);
	virtual void die(Entity*);
	virtual bool_t canSee(Entity*);
	virtual bool_t onLadder();
	virtual void spawnAnim();
	virtual std::string* getTexture();
	virtual bool_t isSleeping();
	virtual bool_t isWaterMob();
	virtual void setSneaking(bool_t);
	virtual float getVoicePitch();
	virtual void playAmbientSound();
	virtual int32_t getAmbientSoundInterval();
	virtual TextureUVCoordinateSet* getItemInHandIcon(const ItemInstance*, int32_t);
	virtual float getBaseSpeed() = 0;
	virtual void superTick();
	virtual void heal(int32_t);
	virtual int32_t getMaxHealth();
	virtual void actuallyHurt(int32_t);
	virtual int32_t getArmorValue();
	virtual HitResult pick(float, float, bool_t);
	virtual void travel(float, float);
	virtual void updateWalkAnim();
	virtual void aiStep();
	virtual void lookAt(Entity*, float, float);
	virtual bool_t isLookingAtAnEntity();
	virtual void beforeRemove();
	virtual bool_t canSpawn();
	virtual void finalizeMobSpawn();
	virtual float getAttackAnim(float);
	virtual Vec3 getPos(float);
	virtual Vec3 getLookAngle() const;
	virtual Vec3 getViewVector(float) const;
	virtual int32_t getMaxSpawnClusterSize();
	virtual bool_t isBaby();
	virtual ItemInstance* getCarriedItem();
	virtual int32_t getUseItemDuration();
	virtual void swing();
	virtual void ate();
	virtual float getMaxHeadXRot();
	virtual Mob* getLastHurtByMob();
	virtual void setLastHurtByMob(Mob*);
	virtual void getLastHurtMob();
	virtual void setLastHurtMob(Entity*);
	virtual Entity* getTarget();
	virtual void setTarget(Mob*);
	virtual bool_t doHurtTarget(Entity*);
	virtual bool_t canBeControlledByRider();
	virtual void teleportTo(float, float, float);
	virtual bool_t removeWhenFarAway();
	virtual int32_t getDeathLoot();
	virtual void dropDeathLoot();
	virtual bool_t isImmobile();
	virtual void jumpFromGround();
	virtual void updateAi();
	virtual void newServerAiStep();
	virtual void serverAiMobStep();
	virtual float getSoundVolume();
	virtual const char_t* getAmbientSound();
	virtual std::string getHurtSound();
	virtual std::string getDeathSound();
	virtual float getWalkingSpeedModifier();
	virtual int32_t getDamageAfterArmorAbsorb(int32_t);
	virtual void hurtArmor(int32_t);
	virtual bool_t useNewAi();
};
